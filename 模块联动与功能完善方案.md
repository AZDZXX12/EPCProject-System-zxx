# ğŸ”„ EPCç³»ç»Ÿæ¨¡å—è”åŠ¨ä¸åŠŸèƒ½å®Œå–„æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•
1. [ç”˜ç‰¹å›¾æ•°æ®æŒä¹…åŒ–ä¼˜åŒ–](#1-ç”˜ç‰¹å›¾æ•°æ®æŒä¹…åŒ–ä¼˜åŒ–)
2. [æ€»åŒ…æ–½å·¥ç®¡ç†æ¨¡å—æ·±åº¦ä¼˜åŒ–](#2-æ€»åŒ…æ–½å·¥ç®¡ç†æ¨¡å—æ·±åº¦ä¼˜åŒ–)
3. [æ¨¡å—é—´æ•°æ®è”åŠ¨æ–¹æ¡ˆ](#3-æ¨¡å—é—´æ•°æ®è”åŠ¨æ–¹æ¡ˆ)
4. [æ•°å­—å­ªç”Ÿé©¾é©¶èˆ±ä¼˜åŒ–](#4-æ•°å­—å­ªç”Ÿé©¾é©¶èˆ±ä¼˜åŒ–)
5. [å®æ—¶æ•°æ®åŒæ­¥æœºåˆ¶](#5-å®æ—¶æ•°æ®åŒæ­¥æœºåˆ¶)

---

## 1. ç”˜ç‰¹å›¾æ•°æ®æŒä¹…åŒ–ä¼˜åŒ–

### å½“å‰é—®é¢˜
```typescript
// âŒ é—®é¢˜ï¼šä¼˜å…ˆä½¿ç”¨LocalStorageï¼Œåç«¯æ•°æ®æˆä¸ºå¤‡ä»½
const cachedData = StorageManager.load(cacheKey);
if (cachedData && cachedData.data && cachedData.data.length > 0) {
  // ç›´æ¥è¿”å›æœ¬åœ°æ•°æ®ï¼Œä¸è¯·æ±‚åç«¯
  return;
}
```

### ä¼˜åŒ–æ–¹æ¡ˆ

#### æ–¹æ¡ˆAï¼šæ™ºèƒ½åŒæ­¥ç­–ç•¥ï¼ˆæ¨èï¼‰
```typescript
// âœ… ä¼˜åŒ–ï¼šåç«¯ä¼˜å…ˆ + æœ¬åœ°ç¼“å­˜ + å†²çªè§£å†³
const loadTasks = async () => {
  setIsLoading(true);
  
  // 1. å…ˆä»LocalStorageå¿«é€ŸåŠ è½½ï¼ˆç«‹å³æ˜¾ç¤ºï¼‰
  const cacheKey = `gantt_tasks_${currentProject.id}`;
  const cachedData = StorageManager.load(cacheKey);
  
  if (cachedData && cachedData.data && cachedData.data.length > 0) {
    console.log('[Gantt] ğŸ“¦ å¿«é€Ÿæ˜¾ç¤ºæœ¬åœ°æ•°æ®');
    window.gantt.parse(cachedData);
    setError(`âš¡ æœ¬åœ°æ•°æ® (${cachedData.data.length} ä¸ªä»»åŠ¡) - æ­£åœ¨åŒæ­¥åç«¯...`);
  }
  
  // 2. å¹¶è¡Œè¯·æ±‚åç«¯æ•°æ®ï¼ˆé™é»˜åŒæ­¥ï¼‰
  try {
    const backendData = await smartFetch(`${API_ENDPOINTS.tasks}?project_id=${currentProject.id}`, {
      timeout: 2000,
      retries: 1
    });
    
    // 3. å¯¹æ¯”æœ¬åœ°å’Œåç«¯æ•°æ®ï¼Œæ™ºèƒ½åˆå¹¶
    const mergedData = mergeTaskData(cachedData?.data || [], backendData);
    
    // 4. æ›´æ–°æ˜¾ç¤ºå’Œç¼“å­˜
    window.gantt.clearAll();
    window.gantt.parse(mergedData);
    StorageManager.save(cacheKey, mergedData);
    
    setError(`âœ… å·²åŒæ­¥ ${backendData.length} ä¸ªä»»åŠ¡`);
    setIsLoading(false);
    
  } catch (error) {
    // åç«¯å¤±è´¥æ—¶ï¼Œç»§ç»­ä½¿ç”¨æœ¬åœ°æ•°æ®
    console.warn('[Gantt] âš ï¸ åç«¯åŒæ­¥å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®');
    setError(`âš ï¸ ç¦»çº¿æ¨¡å¼ (${cachedData?.data?.length || 0} ä¸ªä»»åŠ¡)`);
    setIsLoading(false);
  }
};

// æ™ºèƒ½åˆå¹¶ç®—æ³•
const mergeTaskData = (localTasks: any[], backendTasks: any[]) => {
  const mergedMap = new Map();
  
  // 1. ä»¥åç«¯æ•°æ®ä¸ºåŸºå‡†
  backendTasks.forEach(task => {
    mergedMap.set(task.id, {
      ...task,
      source: 'backend',
      updated_at: task.updated_at || new Date().toISOString()
    });
  });
  
  // 2. åˆå¹¶æœ¬åœ°ä¿®æ”¹ï¼ˆå¦‚æœæœ¬åœ°æ›´æ–°æ—¶é—´æ›´æ™šï¼‰
  localTasks.forEach(localTask => {
    const backendTask = mergedMap.get(localTask.id);
    
    if (!backendTask) {
      // æœ¬åœ°æ–°å¢çš„ä»»åŠ¡
      mergedMap.set(localTask.id, {
        ...localTask,
        source: 'local',
        needsSync: true
      });
    } else if (localTask.updated_at > backendTask.updated_at) {
      // æœ¬åœ°ä¿®æ”¹æ›´æ–°ï¼Œä¿ç•™æœ¬åœ°ç‰ˆæœ¬
      mergedMap.set(localTask.id, {
        ...localTask,
        source: 'local',
        needsSync: true
      });
    }
  });
  
  return {
    data: Array.from(mergedMap.values()),
    links: []
  };
};
```

#### æ–¹æ¡ˆBï¼šå®šæ—¶è‡ªåŠ¨åŒæ­¥
```typescript
// æ¯30ç§’è‡ªåŠ¨åŒæ­¥ä¸€æ¬¡
useEffect(() => {
  const syncInterval = setInterval(async () => {
    await syncTasksToBackend();
  }, 30000);
  
  return () => clearInterval(syncInterval);
}, [currentProject]);

const syncTasksToBackend = async () => {
  const cacheKey = `gantt_tasks_${currentProject.id}`;
  const localData = StorageManager.load(cacheKey);
  
  if (!localData?.data) return;
  
  // æ‰¾å‡ºéœ€è¦åŒæ­¥çš„ä»»åŠ¡ï¼ˆæ ‡è®°ä¸ºneedsSyncï¼‰
  const tasksToSync = localData.data.filter((task: any) => task.needsSync);
  
  if (tasksToSync.length === 0) return;
  
  console.log(`[Gantt] ğŸ”„ è‡ªåŠ¨åŒæ­¥ ${tasksToSync.length} ä¸ªä»»åŠ¡åˆ°åç«¯`);
  
  for (const task of tasksToSync) {
    try {
      await saveTask(task);
      // ç§»é™¤needsSyncæ ‡è®°
      task.needsSync = false;
    } catch (error) {
      console.error(`[Gantt] âŒ åŒæ­¥å¤±è´¥: ${task.id}`);
    }
  }
  
  // æ›´æ–°æœ¬åœ°ç¼“å­˜
  StorageManager.save(cacheKey, localData);
};
```

---

## 2. æ€»åŒ…æ–½å·¥ç®¡ç†æ¨¡å—æ·±åº¦ä¼˜åŒ–

### æ ¸å¿ƒä¼˜åŒ–ç‚¹

#### A. è‡ªåŠ¨æµç¨‹æ¨è¿›
```typescript
// å½“å‰EPCé˜¶æ®µå®Œæˆåï¼Œè‡ªåŠ¨æ¨è¿›åˆ°ä¸‹ä¸€é˜¶æ®µ
const checkAndAdvancePhase = (currentPhase: EPCPhase) => {
  if (currentPhase.progress === 100) {
    const nextPhaseIndex = epcPhases.findIndex(p => p.key === currentPhase.key) + 1;
    
    if (nextPhaseIndex < epcPhases.length) {
      const nextPhase = epcPhases[nextPhaseIndex];
      
      notification.success({
        message: `ğŸ‰ ${currentPhase.name}å®Œæˆï¼`,
        description: `è‡ªåŠ¨è¿›å…¥ä¸‹ä¸€é˜¶æ®µï¼š${nextPhase.name}`,
        duration: 5
      });
      
      // è‡ªåŠ¨æ›´æ–°ä¸‹ä¸€é˜¶æ®µçŠ¶æ€
      updatePhaseStatus(nextPhase.key, 'in_progress');
      
      // è‡ªåŠ¨åˆ›å»ºä¸‹ä¸€é˜¶æ®µçš„ä»»åŠ¡åˆ°ç”˜ç‰¹å›¾
      createPhaseTasksInGantt(nextPhase);
    } else {
      // æ‰€æœ‰é˜¶æ®µå®Œæˆ
      notification.success({
        message: 'ğŸŠ é¡¹ç›®å®Œå·¥ï¼',
        description: 'æ‰€æœ‰EPCé˜¶æ®µå·²å®Œæˆï¼Œè¯·è¿›è¡Œæœ€ç»ˆéªŒæ”¶',
        duration: 10
      });
    }
  }
};
```

#### B. ä¸ç”˜ç‰¹å›¾è”åŠ¨
```typescript
// ç›‘å¬ç”˜ç‰¹å›¾ä»»åŠ¡å˜åŒ–ï¼Œè‡ªåŠ¨æ›´æ–°EPCé˜¶æ®µè¿›åº¦
useEffect(() => {
  if (!window.gantt) return;
  
  // ç›‘å¬ä»»åŠ¡è¿›åº¦å˜åŒ–
  window.gantt.attachEvent('onAfterTaskUpdate', (id: string, task: any) => {
    // æ ¹æ®ä»»åŠ¡æ‰€å±é˜¶æ®µï¼Œæ›´æ–°EPCé˜¶æ®µè¿›åº¦
    updateEPCPhaseFromTask(task);
  });
  
  // ç›‘å¬ä»»åŠ¡å®Œæˆ
  window.gantt.attachEvent('onTaskComplete', (id: string, task: any) => {
    // æ£€æŸ¥è¯¥é˜¶æ®µæ‰€æœ‰ä»»åŠ¡æ˜¯å¦å®Œæˆ
    const phaseCompleted = checkPhaseCompletion(task.phase);
    
    if (phaseCompleted) {
      checkAndAdvancePhase(task.phase);
    }
  });
}, [window.gantt]);

const updateEPCPhaseFromTask = (task: any) => {
  // æ‰¾åˆ°ä»»åŠ¡æ‰€å±çš„EPCé˜¶æ®µ
  const phase = epcPhases.find(p => p.key === task.phase);
  if (!phase) return;
  
  // è®¡ç®—è¯¥é˜¶æ®µæ‰€æœ‰ä»»åŠ¡çš„å¹³å‡è¿›åº¦
  const phaseTasks = window.gantt.getTaskByTime().filter((t: any) => t.phase === phase.key);
  const avgProgress = phaseTasks.reduce((sum, t) => sum + (t.progress || 0), 0) / phaseTasks.length;
  
  // æ›´æ–°EPCé˜¶æ®µè¿›åº¦
  setEpcPhases(prev => prev.map(p => 
    p.key === phase.key 
      ? { ...p, progress: Math.round(avgProgress * 100) }
      : p
  ));
};
```

#### C. æ–½å·¥æ—¥å¿—è‡ªåŠ¨ç”Ÿæˆ
```typescript
// è‡ªåŠ¨è®°å½•å…³é”®æ–½å·¥èŠ‚ç‚¹
const logConstructionEvent = async (event: ConstructionEvent) => {
  const log = {
    id: generateLogId(),
    project_id: currentProject.id,
    phase: event.phase,
    type: event.type, // 'phase_start', 'phase_complete', 'milestone', 'issue'
    title: event.title,
    description: event.description,
    timestamp: new Date().toISOString(),
    created_by: currentUser.name,
    attachments: event.attachments || []
  };
  
  // ä¿å­˜åˆ°åç«¯
  await fetch(`${API_ENDPOINTS.construction_logs}/`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(log)
  });
  
  // å®æ—¶é€šçŸ¥
  notification.info({
    message: 'ğŸ“ æ–½å·¥æ—¥å¿—å·²è®°å½•',
    description: event.title
  });
};

// é˜¶æ®µå¼€å§‹æ—¶è‡ªåŠ¨è®°å½•
const handlePhaseStart = (phase: EPCPhase) => {
  logConstructionEvent({
    phase: phase.key,
    type: 'phase_start',
    title: `${phase.name}å¼€å§‹`,
    description: `å¼€å§‹æ—¶é—´ï¼š${phase.startDate}ï¼Œé¢„è®¡å·¥æœŸï¼š${phase.duration}å¤©ï¼Œè´Ÿè´£äººï¼š${phase.responsible}`
  });
};

// é˜¶æ®µå®Œæˆæ—¶è‡ªåŠ¨è®°å½•
const handlePhaseComplete = (phase: EPCPhase) => {
  logConstructionEvent({
    phase: phase.key,
    type: 'phase_complete',
    title: `${phase.name}å®Œæˆ`,
    description: `å®Œæˆæ—¶é—´ï¼š${new Date().toISOString()}ï¼Œå®é™…è¿›åº¦ï¼š${phase.progress}%ï¼Œäº¤ä»˜ç‰©ï¼š${phase.deliverables.join(', ')}`
  });
};
```

#### D. å®‰å…¨è´¨é‡æ£€æŸ¥é›†æˆ
```typescript
// æ¯ä¸ªé˜¶æ®µè‡ªåŠ¨è§¦å‘å®‰å…¨è´¨é‡æ£€æŸ¥
const triggerSafetyQualityCheck = async (phase: EPCPhase) => {
  const checks = {
    safety: [
      { item: 'æ–½å·¥äººå‘˜å®‰å…¨åŸ¹è®­', status: 'pending' },
      { item: 'å®‰å…¨è®¾å¤‡é…å¤‡æ£€æŸ¥', status: 'pending' },
      { item: 'ç°åœºå®‰å…¨éšæ‚£æ’æŸ¥', status: 'pending' }
    ],
    quality: [
      { item: 'ææ–™è´¨é‡æ£€éªŒ', status: 'pending' },
      { item: 'æ–½å·¥å·¥è‰ºéªŒæ”¶', status: 'pending' },
      { item: 'è´¨é‡æ–‡æ¡£å®¡æ ¸', status: 'pending' }
    ]
  };
  
  // æ˜¾ç¤ºæ£€æŸ¥æ¸…å•
  Modal.confirm({
    title: `${phase.name} - å®‰å…¨è´¨é‡æ£€æŸ¥`,
    content: (
      <ChecklistForm 
        safetyItems={checks.safety}
        qualityItems={checks.quality}
        onComplete={handleChecksComplete}
      />
    ),
    width: 800
  });
};
```

---

## 3. æ¨¡å—é—´æ•°æ®è”åŠ¨æ–¹æ¡ˆ

### A. é¡¹ç›® â†’ ç”˜ç‰¹å›¾ â†’ æ–½å·¥ç®¡ç† â†’ è®¾å¤‡

```typescript
// å…¨å±€æ•°æ®æµç®¡ç†
interface ProjectDataFlow {
  project: Project;           // é¡¹ç›®åŸºç¡€ä¿¡æ¯
  ganttTasks: Task[];         // ç”˜ç‰¹å›¾ä»»åŠ¡
  epcPhases: EPCPhase[];      // EPCé˜¶æ®µ
  devices: Device[];          // è®¾å¤‡åˆ—è¡¨
  logs: ConstructionLog[];    // æ–½å·¥æ—¥å¿—
}

// ä½¿ç”¨React Contextå®ç°å…¨å±€æ•°æ®å…±äº«
const ProjectDataContext = createContext<ProjectDataFlow | null>(null);

export const ProjectDataProvider: React.FC = ({ children }) => {
  const [projectData, setProjectData] = useState<ProjectDataFlow>({
    project: null,
    ganttTasks: [],
    epcPhases: [],
    devices: [],
    logs: []
  });
  
  // ç›‘å¬é¡¹ç›®åˆ‡æ¢
  useEffect(() => {
    if (currentProject) {
      loadAllProjectData(currentProject.id);
    }
  }, [currentProject]);
  
  // åŠ è½½æ‰€æœ‰å…³è”æ•°æ®
  const loadAllProjectData = async (projectId: string) => {
    const [project, tasks, phases, devices, logs] = await Promise.all([
      fetchProject(projectId),
      fetchTasks(projectId),
      fetchEPCPhases(projectId),
      fetchDevices(projectId),
      fetchConstructionLogs(projectId)
    ]);
    
    setProjectData({
      project,
      ganttTasks: tasks,
      epcPhases: phases,
      devices,
      logs
    });
  };
  
  // æ•°æ®æ›´æ–°æ–¹æ³•
  const updateGanttTask = async (taskId: string, updates: Partial<Task>) => {
    // 1. æ›´æ–°ç”˜ç‰¹å›¾ä»»åŠ¡
    const updatedTask = await saveTaskToBackend(taskId, updates);
    
    // 2. åŒæ­¥æ›´æ–°EPCé˜¶æ®µè¿›åº¦
    const phase = epcPhases.find(p => p.tasks?.includes(taskId));
    if (phase) {
      updateEPCPhaseProgress(phase);
    }
    
    // 3. è§¦å‘å…³è”è®¾å¤‡çŠ¶æ€æ›´æ–°
    if (updatedTask.devices) {
      updateDeviceStatus(updatedTask.devices);
    }
    
    // 4. è®°å½•æ–½å·¥æ—¥å¿—
    logTaskUpdate(updatedTask);
    
    // 5. æ›´æ–°å…¨å±€æ•°æ®
    setProjectData(prev => ({
      ...prev,
      ganttTasks: prev.ganttTasks.map(t => 
        t.id === taskId ? { ...t, ...updates } : t
      )
    }));
  };
  
  return (
    <ProjectDataContext.Provider value={{ projectData, updateGanttTask }}>
      {children}
    </ProjectDataContext.Provider>
  );
};
```

### B. æ•°æ®è”åŠ¨ç¤ºä¾‹

#### ç¤ºä¾‹1ï¼šç”˜ç‰¹å›¾ä»»åŠ¡å®Œæˆ â†’ è‡ªåŠ¨æ›´æ–°æ–½å·¥è¿›åº¦
```typescript
// åœ¨ç”˜ç‰¹å›¾ç»„ä»¶ä¸­
const handleTaskComplete = async (task: Task) => {
  // 1. æ ‡è®°ä»»åŠ¡å®Œæˆ
  await updateGanttTask(task.id, { progress: 100, status: 'completed' });
  
  // 2. æ£€æŸ¥EPCé˜¶æ®µæ˜¯å¦å®Œæˆ
  const phase = epcPhases.find(p => p.tasks?.includes(task.id));
  if (phase) {
    const allTasksCompleted = phase.tasks.every(tid => {
      const t = ganttTasks.find(gt => gt.id === tid);
      return t?.progress === 100;
    });
    
    if (allTasksCompleted) {
      // 3. è‡ªåŠ¨æ¨è¿›åˆ°ä¸‹ä¸€é˜¶æ®µ
      await advanceToNextPhase(phase);
      
      // 4. ç”Ÿæˆé˜¶æ®µå®ŒæˆæŠ¥å‘Š
      generatePhaseCompletionReport(phase);
    }
  }
  
  // 5. é€šçŸ¥ç›¸å…³äººå‘˜
  notifyTaskCompletion(task);
};
```

#### ç¤ºä¾‹2ï¼šè®¾å¤‡é‡‡è´­ â†’ è‡ªåŠ¨æ›´æ–°æ–½å·¥è®¡åˆ’
```typescript
// åœ¨è®¾å¤‡ç®¡ç†ç»„ä»¶ä¸­
const handleDeviceArrival = async (device: Device) => {
  // 1. æ›´æ–°è®¾å¤‡çŠ¶æ€
  await updateDevice(device.id, { status: 'arrived' });
  
  // 2. æ‰¾åˆ°ä¾èµ–è¯¥è®¾å¤‡çš„ä»»åŠ¡
  const dependentTasks = ganttTasks.filter(t => 
    t.dependencies?.includes(`device:${device.id}`)
  );
  
  // 3. è‡ªåŠ¨æ¿€æ´»è¿™äº›ä»»åŠ¡
  for (const task of dependentTasks) {
    await updateGanttTask(task.id, { 
      status: 'ready',
      canStart: true
    });
    
    notification.success({
      message: 'ğŸ“¦ è®¾å¤‡åˆ°è´§',
      description: `${device.name}å·²åˆ°è´§ï¼Œä»»åŠ¡"${task.name}"å¯ä»¥å¼€å§‹`
    });
  }
  
  // 4. æ›´æ–°æ–½å·¥è¿›åº¦é¢„æµ‹
  recalculateProjectSchedule();
};
```

#### ç¤ºä¾‹3ï¼šæ–½å·¥æ—¥å¿— â†’ è‡ªåŠ¨é£é™©é¢„è­¦
```typescript
// æ™ºèƒ½é£é™©æ£€æµ‹
const analyzeConstructionRisks = (log: ConstructionLog) => {
  const risks = [];
  
  // æ£€æµ‹å»¶æœŸé£é™©
  if (log.type === 'delay') {
    const affectedTasks = ganttTasks.filter(t => 
      t.start_date > new Date(log.timestamp)
    );
    
    risks.push({
      level: 'high',
      type: 'schedule',
      message: `æ–½å·¥å»¶æœŸå¯èƒ½å½±å“${affectedTasks.length}ä¸ªåç»­ä»»åŠ¡`,
      affectedTasks
    });
  }
  
  // æ£€æµ‹è´¨é‡é£é™©
  if (log.type === 'quality_issue') {
    risks.push({
      level: 'critical',
      type: 'quality',
      message: 'å‘ç°è´¨é‡é—®é¢˜ï¼Œéœ€è¦ç«‹å³æ•´æ”¹',
      phase: log.phase
    });
  }
  
  // æ£€æµ‹å®‰å…¨é£é™©
  if (log.type === 'safety_issue') {
    risks.push({
      level: 'critical',
      type: 'safety',
      message: 'å‘ç°å®‰å…¨éšæ‚£ï¼Œå¿…é¡»ç«‹å³å¤„ç†',
      requiresAction: true
    });
  }
  
  // æ˜¾ç¤ºé£é™©é¢„è­¦
  if (risks.length > 0) {
    showRiskAlerts(risks);
  }
};
```

---

## 4. æ•°å­—å­ªç”Ÿé©¾é©¶èˆ±ä¼˜åŒ–

### A. 3Dåœºæ™¯ä¼˜åŒ–

```typescript
// ä¼˜åŒ–Three.jsæ€§èƒ½
import { DigitalTwin } from '../components/DigitalTwin/Scene';

const DigitalTwinDashboard: React.FC = () => {
  const [sceneData, setSceneData] = useState({
    buildings: [],
    equipment: [],
    workers: [],
    progress: 0
  });
  
  // å®æ—¶æ›´æ–°3Dåœºæ™¯
  useEffect(() => {
    const updateInterval = setInterval(() => {
      updateSceneFromProjectData();
    }, 5000); // æ¯5ç§’æ›´æ–°ä¸€æ¬¡
    
    return () => clearInterval(updateInterval);
  }, []);
  
  const updateSceneFromProjectData = async () => {
    // 1. è·å–æœ€æ–°é¡¹ç›®æ•°æ®
    const projectData = await fetchProjectRealTimeData();
    
    // 2. è½¬æ¢ä¸º3Dåœºæ™¯æ•°æ®
    const scene3D = {
      buildings: projectData.phases.map(phase => ({
        id: phase.id,
        name: phase.name,
        position: calculateBuildingPosition(phase),
        progress: phase.progress,
        color: getPhaseColor(phase),
        status: phase.status
      })),
      
      equipment: projectData.devices.map(device => ({
        id: device.id,
        name: device.name,
        model: getDeviceModel(device.type),
        position: device.location,
        status: device.status,
        operationData: device.realtimeData
      })),
      
      workers: projectData.workers.map(worker => ({
        id: worker.id,
        name: worker.name,
        position: worker.currentLocation,
        task: worker.currentTask,
        safetyStatus: worker.safetyEquipment
      })),
      
      progress: projectData.overallProgress
    };
    
    setSceneData(scene3D);
  };
  
  return (
    <div style={{ width: '100%', height: '100vh' }}>
      {/* 3Dåœºæ™¯ */}
      <DigitalTwin
        buildings={sceneData.buildings}
        equipment={sceneData.equipment}
        workers={sceneData.workers}
        onObjectClick={handleObjectClick}
      />
      
      {/* å®æ—¶æ•°æ®é¢æ¿ */}
      <RealtimeDataPanel
        progress={sceneData.progress}
        activePhases={sceneData.buildings.filter(b => b.status === 'active')}
        activeEquipment={sceneData.equipment.filter(e => e.status === 'running')}
        onlineWorkers={sceneData.workers.length}
      />
      
      {/* æ§åˆ¶é¢æ¿ */}
      <ControlPanel
        onViewChange={handleViewChange}
        onFilterChange={handleFilterChange}
        onExport={handleExportReport}
      />
    </div>
  );
};
```

### B. å®æ—¶æ•°æ®å±•ç¤º

```typescript
// å®æ—¶æ•°æ®æµ
interface RealtimeDataStream {
  projectProgress: number;
  activePhases: string[];
  workersOnSite: number;
  equipmentRunning: number;
  safetyAlerts: SafetyAlert[];
  qualityMetrics: QualityMetrics;
  todayProgress: {
    tasksCompleted: number;
    tasksTotal: number;
    hoursWorked: number;
  };
}

const useRealtimeData = (projectId: string) => {
  const [data, setData] = useState<RealtimeDataStream | null>(null);
  
  useEffect(() => {
    // WebSocketè¿æ¥ï¼ˆå¦‚æœåç«¯æ”¯æŒï¼‰
    const ws = new WebSocket(`wss://epc-backend.onrender.com/ws/project/${projectId}`);
    
    ws.onmessage = (event) => {
      const realtimeData = JSON.parse(event.data);
      setData(realtimeData);
    };
    
    // é™çº§æ–¹æ¡ˆï¼šè½®è¯¢
    if (ws.readyState !== WebSocket.OPEN) {
      const pollInterval = setInterval(async () => {
        const realtimeData = await fetch(
          `${API_ENDPOINTS.projects}/${projectId}/realtime`
        ).then(res => res.json());
        
        setData(realtimeData);
      }, 5000);
      
      return () => clearInterval(pollInterval);
    }
    
    return () => ws.close();
  }, [projectId]);
  
  return data;
};

// ä½¿ç”¨å®æ—¶æ•°æ®
const RealtimeDataPanel: React.FC = () => {
  const realtimeData = useRealtimeData(currentProject.id);
  
  return (
    <div className="realtime-panel">
      <Row gutter={16}>
        <Col span={6}>
          <Statistic 
            title="é¡¹ç›®è¿›åº¦" 
            value={realtimeData?.projectProgress} 
            suffix="%"
            prefix={<RiseOutlined />}
          />
        </Col>
        <Col span={6}>
          <Statistic 
            title="åœ¨åœºäººå‘˜" 
            value={realtimeData?.workersOnSite}
            suffix="äºº"
          />
        </Col>
        <Col span={6}>
          <Statistic 
            title="è¿è¡Œè®¾å¤‡" 
            value={realtimeData?.equipmentRunning}
            suffix="å°"
          />
        </Col>
        <Col span={6}>
          <Statistic 
            title="ä»Šæ—¥å®Œæˆ" 
            value={realtimeData?.todayProgress.tasksCompleted}
            suffix={`/${realtimeData?.todayProgress.tasksTotal}`}
          />
        </Col>
      </Row>
      
      {/* å®‰å…¨é¢„è­¦ */}
      {realtimeData?.safetyAlerts && realtimeData.safetyAlerts.length > 0 && (
        <Alert
          type="warning"
          message={`${realtimeData.safetyAlerts.length}ä¸ªå®‰å…¨æç¤º`}
          description={
            <List
              dataSource={realtimeData.safetyAlerts}
              renderItem={alert => (
                <List.Item>{alert.message}</List.Item>
              )}
            />
          }
        />
      )}
    </div>
  );
};
```

---

## 5. å®æ—¶æ•°æ®åŒæ­¥æœºåˆ¶

### A. WebSocketå®æ—¶é€šä¿¡ï¼ˆæ¨èï¼‰

```python
# server/quick-start-sqlite.py
from fastapi import WebSocket, WebSocketDisconnect
from typing import List, Dict

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}
    
    async def connect(self, websocket: WebSocket, project_id: str):
        await websocket.accept()
        if project_id not in self.active_connections:
            self.active_connections[project_id] = []
        self.active_connections[project_id].append(websocket)
        print(f"[WS] Client connected to project {project_id}")
    
    def disconnect(self, websocket: WebSocket, project_id: str):
        self.active_connections[project_id].remove(websocket)
        print(f"[WS] Client disconnected from project {project_id}")
    
    async def broadcast(self, project_id: str, message: dict):
        if project_id in self.active_connections:
            for connection in self.active_connections[project_id]:
                await connection.send_json(message)

manager = ConnectionManager()

@app.websocket("/ws/project/{project_id}")
async def websocket_endpoint(websocket: WebSocket, project_id: str):
    await manager.connect(websocket, project_id)
    try:
        while True:
            # ä¿æŒè¿æ¥
            data = await websocket.receive_text()
            print(f"[WS] Received: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket, project_id)

# å½“ä»»åŠ¡æ›´æ–°æ—¶å¹¿æ’­
@app.put("/api/v1/tasks/{task_id}")
async def update_task(task_id: str, task: Task):
    # ... æ›´æ–°æ•°æ®åº“ ...
    
    # å¹¿æ’­æ›´æ–°
    await manager.broadcast(task.project_id, {
        "type": "task_updated",
        "task": task.dict()
    })
    
    return {"message": "Task updated"}
```

### B. å‰ç«¯WebSocketå®¢æˆ·ç«¯

```typescript
// client/src/services/WebSocketService.ts
class WebSocketService {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  connect(projectId: string, onMessage: (data: any) => void) {
    const wsUrl = `${API_BASE_URL.replace('http', 'ws')}/ws/project/${projectId}`;
    
    this.ws = new WebSocket(wsUrl);
    
    this.ws.onopen = () => {
      console.log('[WS] Connected');
      this.reconnectAttempts = 0;
    };
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      onMessage(data);
    };
    
    this.ws.onerror = (error) => {
      console.error('[WS] Error:', error);
    };
    
    this.ws.onclose = () => {
      console.log('[WS] Disconnected');
      this.reconnect(projectId, onMessage);
    };
  }
  
  private reconnect(projectId: string, onMessage: (data: any) => void) {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`[WS] Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      
      setTimeout(() => {
        this.connect(projectId, onMessage);
      }, 2000 * this.reconnectAttempts);
    }
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

export const wsService = new WebSocketService();
```

---

## 6. å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šæ•°æ®æŒä¹…åŒ–ï¼ˆ1-2å¤©ï¼‰
- [x] ç”˜ç‰¹å›¾æ™ºèƒ½åŒæ­¥ç­–ç•¥
- [x] å®šæ—¶è‡ªåŠ¨åŒæ­¥æœºåˆ¶
- [ ] å†²çªè§£å†³ç®—æ³•
- [ ] ç¦»çº¿æ•°æ®é˜Ÿåˆ—

### ç¬¬äºŒé˜¶æ®µï¼šæ¨¡å—è”åŠ¨ï¼ˆ2-3å¤©ï¼‰
- [ ] å…¨å±€æ•°æ®æµç®¡ç†(Context)
- [ ] ç”˜ç‰¹å›¾ â†” æ–½å·¥ç®¡ç†è”åŠ¨
- [ ] è®¾å¤‡ â†” ä»»åŠ¡è”åŠ¨
- [ ] è‡ªåŠ¨åŒ–æµç¨‹æ¨è¿›

### ç¬¬ä¸‰é˜¶æ®µï¼šå®æ—¶åŒæ­¥ï¼ˆ3-4å¤©ï¼‰
- [ ] WebSocketæœåŠ¡ç«¯
- [ ] WebSocketå®¢æˆ·ç«¯
- [ ] å®æ—¶æ•°æ®æµ
- [ ] æ–­çº¿é‡è¿æœºåˆ¶

### ç¬¬å››é˜¶æ®µï¼šæ•°å­—å­ªç”Ÿï¼ˆ4-5å¤©ï¼‰
- [ ] 3Dåœºæ™¯ä¼˜åŒ–
- [ ] å®æ—¶æ•°æ®å±•ç¤º
- [ ] äº¤äº’æ§åˆ¶é¢æ¿
- [ ] æ•°æ®å¯è§†åŒ–

---

## 7. é¢„æœŸæ•ˆæœ

### ç”¨æˆ·ä½“éªŒ
âœ… **æ•°æ®ä¸€è‡´æ€§** - æ‰€æœ‰æ¨¡å—æ•°æ®å®æ—¶åŒæ­¥  
âœ… **æ™ºèƒ½è”åŠ¨** - ä¸€ä¸ªæ¨¡å—æ“ä½œè‡ªåŠ¨å½±å“å…¶ä»–æ¨¡å—  
âœ… **å®æ—¶åé¦ˆ** - WebSocketæ¨é€ï¼Œæ— éœ€åˆ·æ–°  
âœ… **ç¦»çº¿å¯ç”¨** - æœ¬åœ°ç¼“å­˜ + è‡ªåŠ¨åŒæ­¥  

### æŠ€æœ¯æŒ‡æ ‡
âœ… **æ•°æ®åŒæ­¥å»¶è¿Ÿ** < 1ç§’  
âœ… **ç•Œé¢å“åº”æ—¶é—´** < 100ms  
âœ… **3Dæ¸²æŸ“å¸§ç‡** > 30fps  
âœ… **WebSocketè¿æ¥ç¨³å®šæ€§** > 99%  

---

**æ–¹æ¡ˆåˆ›å»ºæ—¶é—´**ï¼š2025-11-07  
**é¢„è®¡å®Œæˆæ—¶é—´**ï¼š2å‘¨å†…  
**ä¼˜å…ˆçº§**ï¼šé«˜  
**çŠ¶æ€**ï¼šå¾…å®æ–½

